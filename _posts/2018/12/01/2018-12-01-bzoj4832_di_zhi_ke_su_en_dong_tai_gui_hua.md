---
title: "BZOJ 4832 - 抵制克苏恩 - 动态规划"
date: 2018-12-01 23:50:35 +0800
last_modified_at: 2018-12-01 23:50:35 +0800
math: true
render_with_liquid: false
categories: ["ACM", "动态规划"]
tags: ["动态规划", "题解"]
---

## BZOJ 4832 - 抵制克苏恩 - 动态规划

### 题解链接

https://lucien.ink

---
### 题目链接

https://www.lydsy.com/JudgeOnline/problem.php?id=4832

---
### 题目

小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。如果你不玩炉石传说，不必担心，小Q同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个 30 点血量的英雄，并且可以用牌召唤至多 7个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白告诉他使用奴隶主这张牌就可以啦。如果你不明白我上面在说什么，不必担心，小Q同学会告诉你他想让你做什么。现在小Q同学会给出克苏恩的攻击力是 K ，表示克苏恩会攻击 K 次，每次会从对方场上的英雄和随从中随机选择一个并对其产生 1 点伤害。现在对方有一名克苏恩，你有一些奴隶主作为随从，每名奴隶主的血量是给定的。如果克苏恩攻击了你的一名奴隶主，那么这名奴隶主的血量会减少 1 点，当其血量小于等于 0 时会死亡，如果受到攻击后不死亡，并且你的随从数量没有达到 7 ，这名奴隶主会召唤一个拥有 3 点血量的新奴隶主作为你的随从；如果克苏恩攻击了你的英雄，你的英雄会记录受到 1 点伤害。你应该注意到了，每当克苏恩进行一次攻击，你场上的随从可能发生很大的变化。小Q同学为你假设了克苏恩的攻击力，你场上分别有 1 点、 2 点、 3 点血量的奴隶主数量，你可以计算出你的英雄受到的总伤害的期望值是多少吗？

---
### 思路

&emsp;&emsp;记$f[t][i][j][k]$和$g[t][i][j][k]$代表第$t$轮攻击中，有$i$个血量为$1$的奴隶主、$j$个血量为$2$的奴隶主、$k$个血量为$3$的奴隶主时，玩家受到的伤害的期望值以及这种状态发生的概率。

&emsp;&emsp;这样以来转移就很顺其自然了。网上有很短的离线写法，不是很懂，我目前只会比较笨的这种辅助`DP`，代码又臭又长，但我自认为是比较好想以及理解的。

---
### 实现

https://pasteme.cn/2118

```cpp
## include <bits/stdc++.h>
double f[57][8][8][8], g[57][8][8][8];
void init() {
    memset(f, 0, sizeof(f));
    memset(g, 0, sizeof(g));
}
int _, n, a, b, c;
int main() {
    for (scanf("%d", &_); init(), _; _--) {
        scanf("%d%d%d%d", &n, &a, &b, &c);
        f[0][a][b][c] = 0, g[0][a][b][c] = 1;
        for (int t = 0; t < n; t++) {
            for (int i = 0; i <= 7; i++) {
                for (int j = 0; i + j <= 7; j++) {
                    for (int k = 0; i + j + k <= 7; k++) {
                        if (g[t][i][j][k] < 1e-9) continue;
                        double tmp = 1.0 / (i + j + k + 1);
                        f[t + 1][i][j][k] += (f[t][i][j][k] + g[t][i][j][k]) * tmp;
                        g[t + 1][i][j][k] += g[t][i][j][k] * tmp;
                        if (i) {
                            g[t + 1][i - 1][j][k] += g[t][i][j][k] * i * tmp;
                            f[t + 1][i - 1][j][k] += f[t][i][j][k] * i * tmp;
                        }
                        if (i + j + k < 7) {
                            if (j) {
                                g[t + 1][i + 1][j - 1][k + 1] += g[t][i][j][k] * j * tmp;
                                f[t + 1][i + 1][j - 1][k + 1] += f[t][i][j][k] * j * tmp;
                            }
                            if (k) {
                                g[t + 1][i][j + 1][k] += g[t][i][j][k] * k * tmp;
                                f[t + 1][i][j + 1][k] += f[t][i][j][k] * k * tmp;
                            }
                        } else {
                            if (j) {
                                g[t + 1][i + 1][j - 1][k] += g[t][i][j][k] * j * tmp;
                                f[t + 1][i + 1][j - 1][k] += f[t][i][j][k] * j * tmp;
                            }
                            if (k) {
                                g[t + 1][i][j + 1][k - 1] += g[t][i][j][k] * k * tmp;
                                f[t + 1][i][j + 1][k - 1] += f[t][i][j][k] * k * tmp;
                            }
                        }
                    }
                }
            }
        }
        double ans = 0;
        for (int i = 0; i <= 7; i++) {
            for (int j = 0; i + j <= 7; j++) {
                for (int k = 0; i + j + k <= 7; k++) {
                    if (g[n][i][j][k] < 1e-9) continue;
                    ans += f[n][i][j][k];
                }
            }
        }
        printf("%.2f\n", ans);
    }
    return 0;
}
```