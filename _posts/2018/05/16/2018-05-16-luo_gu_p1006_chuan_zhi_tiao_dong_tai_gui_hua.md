---
title: "洛谷P1006 - 传纸条 - 动态规划"
date: 2018-05-16 15:22:00 +0800
last_modified_at: 2018-05-16 15:22:28 +0800
math: true
render_with_liquid: false
categories: ["ACM", "动态规划"]
tags: ["动态规划"]
---

### 题解链接：



---
### 题目链接：

https://www.luogu.org/problemnew/show/P1006

---
### 题目：

#### 题目描述

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。

#### 输入输出格式

##### 输入格式：
输入文件message.in的第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1<=m,n<=50）。

接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。

##### 输出格式：
输出文件message.out共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

### 说明

【限制】

30%的数据满足：1<=m,n<=10

100%的数据满足：1<=m,n<=50

---
### 思路：

&emsp;&emsp;显然，一来一回的路径不能有交叉，其次，这两条路径可以看做是同时从左上角出发传递至右下角的。

&emsp;&emsp;可以注意到`n`和`m`都很小，最简单的方法就是$O(n^4)$，直接暴力转移即可，在这里就不说了。

&emsp;&emsp;如果`n`和`m`比较大，考虑$O(n^3)$的做法，因为两个点都只能向右或向下走，所以对于一个点来说，每走一步要么$x = x + 1$，要么$y = y + 1$，也就是说这两个点每走一步，他们的横纵坐标之和$x + y$都会自增$1$，又因为他们俩开始的时候是在同一个点，则有：在行进的过程中，他们俩各自的横纵坐标之和始终相等。

&emsp;&emsp;于是我们可以枚举横纵坐标之和，然后再枚举这两个点的横坐标或者是纵坐标进行转移，就能将复杂度降至$O(n^3)$。

---
### 实现：

```cpp
## include <bits/stdc++.h>
const int maxn = 107;
int n, m, dp[maxn << 1][maxn][maxn], a[maxn][maxn];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf("%d", a[i] + j);
    memset(dp, 0xff, sizeof(dp));
    dp[3][1][2] = dp[3][2][1] = 0;
    for (int step = 3; step < n + m; step++) {
        for (int i = 1; i <= m; i++) { //
            for (int j = i + 1; j <= m; j++) {
                int tmp = dp[step][i][j];
                tmp = std::max(tmp, dp[step - 1][i][j]);
                tmp = std::max(tmp, dp[step - 1][i - 1][j]);
                if (i != j - 1) tmp = std::max(tmp, dp[step - 1][i][j - 1]);
                tmp = std::max(tmp, dp[step - 1][i - 1][j - 1]);
                if (~tmp) dp[step][i][j] = tmp + a[step - i][i] + a[step - j][j];
            }
        }
    }
    printf("%d\n", dp[n + m - 1][m - 1][m]);
    return 0;
}
```