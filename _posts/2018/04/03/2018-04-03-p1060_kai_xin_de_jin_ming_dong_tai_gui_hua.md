---
title: "P1060 - 开心的金明 - 动态规划"
date: 2018-04-03 13:22:42 +0800
last_modified_at: 2018-04-03 13:22:52 +0800
math: true
render_with_liquid: false
categories: ["ACM", "动态规划"]
tags: ["动态规划"]
---

### 题目链接：

https://www.luogu.org/problemnew/show/P1060

---
### 题目：

#### 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1，j2，……，jk，则所求的总和为：

$v[j_1]*w[j_1]+v[j_2]*w[j_2]+ …+v[j_k]*w[j_k]$。（其中*为乘号）

请你帮助金明设计一个满足要求的购物单。

#### 输入格式：
输入的第1行，为两个正整数，用一个空格隔开：

N m （其中N（<30000）表示总钱数，m（<25）为希望购买物品的个数。）

从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数

v p （其中v表示该物品的价格(v<=10000)，p表示该物品的重要度(1~5)）

#### 输出格式：
输出只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<100000000）。

#### 输入样例#1：
```
1000 5
800 2
400 5
300 5
400 3
200 2
```
#### 输出样例#1：
```
3900
```

---
### 思路：

&emsp;&emsp;因为一个主件最多有两个附属，每个附属只属于一个主件，所以我们可以开一个$60 \times 3$的数组来存储物品信息，对于第$i$个主件，`cost[i][0]`表示主件的消耗，`cost[i][1]`和`cost[i][2]`分别表示两个附属组件的消耗，然后背包即可。

一点小优化：

&emsp;&emsp;注意到钱的数目是10的整数倍，所以我们可以对所有的`cost`先缩小十倍，然后再进行运算，输出答案时再扩大十倍即可。我们还可以把`val`直接处理成每个物品的价格和重要度的乘积存储起来，在背包的过程中可以减少书写和运算。

---
### 实现：

```cpp
## include <bits/stdc++.h>
int dp[3207], cost[67][7], val[67][7], len[67], tot, idx[67];
int n, m;
int main() {
//    freopen("in.txt", "r", stdin);
    scanf("%d%d", &n, &m);
    n /= 10;
    for (int i = 1, v, p, q, cur; i <= m; i++) {
        scanf("%d%d%d", &v, &p, &q);
        v /= 10;
        cur = q ? idx[q] : idx[i] = ++tot;
        cost[cur][len[cur]] = v;
        val[cur][len[cur]++] = v * p;
    }
    for (int i = 1; i <= tot; i++) {
        for (int v = n; v >= cost[i][0]; v--) {
            dp[v] = std::max(dp[v], dp[v - cost[i][0]] + val[i][0]);
            for (int k = 1; k <= 2; k++) if (v >= cost[i][0] + cost[i][k])
                    dp[v] = std::max(dp[v], dp[v - cost[i][0] - cost[i][k]] + val[i][0] + val[i][k]);
            if (v >= cost[i][0] + cost[i][1] + cost[i][2])
                dp[v] = std::max(dp[v], dp[v - cost[i][0] - cost[i][1] - cost[i][2]] + val[i][0] + val[i][1] + val[i][2]);
        }
    }
    printf("%d\n", dp[n] * 10);
    return 0;
}
```